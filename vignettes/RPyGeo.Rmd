---
title: "RPyGeo"
author: "Marc Becker and Fabian Polakowski"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: refs.bib
biblio-style: apalike
link-citations: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

**RPyGeo** establishes an interface to the geoprocessing tools of ArcGIS from within R.
Since ArcGIS only provides a Python API for a low-level access of its C++ based geoalgorithms, **RPyGeo** establishes a tunnel to Python via the **reticulate** package.
This extends R's spatial capabilities [@bivand_applied_2013; @hijmans_raster_2017; @pebesma_simple_2018] by the geoalgorithms and the geoprocessing power of ArcGIS.
Combining this with the statistical and data science power of R opens the way to advanced console-base statistical geoprocessing [@muenchow_rqgis_2017]. 

## ArcPy

To use **RpyGeo** properly, at least a basic understanding of ArcPy is necessary.
ArcPy is a Python side-package that allows geographic data analysis through ArcGIS from the Python command line.
ArcPy is organized into modules which are Python files with functions and classes. The ArcPy main module `arcpy` (and `arcgis`, respectively depending on the used ArcGIS version <!-- Marc, pls check if this is right -->) provides (geographic) classes and several hundred functions.
Further modules (e.g., `data access`) and extensions (e.g., `spatial analysis`) further extend the ArcPy main module.
We do recommend to get familiar with ArcPy through the official [help pages](https://pro.arcgis.com/en/pro-app/arcpy/main/arcgis-pro-arcpy-reference.htm). 
There also several books available on ArcGIS and ArcPy such as 
@zandbergen_python_2013 and [@pimpler_programming_2015].
<!-- JM: not really sure what you would like to say here or if this might be even too much detail


The ArcPy functions are essentially wrapper for the ArcGIS geoprocessing tools and other scripting tasks.  
The ArcPy classes are blueprints for any kind of object in ArcPy. 
For example, `Point` and `Raster` are classes to describe geographic data. ArcPy classes are also used to set geoprocessing environment settings (e.g., `workspace` or `extent`).
-->

## Tutorial

In order to use **RPyGeo** you need a working ArcMap or ArcGIS Pro installation on your computer. 

This tutorial requires the following packages to be installed and attached:

```{r, eval=FALSE}
library("RpyGeo")
library("spData")
library("sf")
library("raster")
library("magrittr")
```

<!-- well, this is an "artificial" dem, why don't you just use data(dem, package = "RQGIS")-->
To demonstrate both raster and vector operations we will use the raster object `elev` and the vector object `nz` from the **spData** package.
To make these datasets available for the subsequent ArcMap geoprocessing, we have to save them on disk first.
Therefore, we export `nz` and `elev` to a temporary directory.

```{r, eval = FALSE}
data(elev, nz, package = "spData")
writeRaster(elev, file.path(tempdir(), "elev.tif"), format = "GTiff")
st_write(nz, file.path(tempdir(), "nz.shp"))
```

### Establishing the ArcPy Python interface in R

Powered by **reticulate**, `rpygeo_build_env()` will establish an R interface to Python.
ArcPy will only work with the Python binary that comes with the ArcGIS installation.
If this Python binary is not installed in the default location (`C:/Python27` in the case of ArcMap and `C:/Program Files/ArcGIS/Pro/bin/Python/envs/arcgispro-py3` in the case of ArcGIS Pro), one can set it explicitly with the `path` parameter of `rpygeo_build_env()`. 
Secondly, `rpygeo_build_env()` loads the `arcpy` library.

```{r, eval = FALSE}
arcpy <- rpygeo_build_env(workspace = tempdir(),
                          overwrite = TRUE,
                          extensions = "Spatial")
```

`rpygeo_build_env()` lets the user also specify further common ArcGIS environment settings.
For instance, setting `overwrite` to `TRUE` lets the user overwrite already existing spatial objects later on with outputs created by ArcPy geoalgorithms.
The `extensions` parameter allows also the activation of extensions.^[The availability of extensions is dependent on the purchased ArcGIS license.]
In the code chunk above, we have enabled the Spatial Analysis extension.
The `workspace` parameter defines the default directory where to save the outputs of geoprocessing functions and in which to look for spatial objects. 
Note that the workspace can be a directory or an ESRI file geodatabase.^[If you work with large raster files we would recommend to use a directory, because it takes a long time to load raster datasets from a file geodatabase into an R session.]
A scratch workspace folder is automatically created inside the workspace. 
The scratch workspace usually contains the output files of functions that do not explicitly provide an output parameter as is the case for most spatial analyst raster algorithms.
To change the default scratch workspace location, use parameter `scratch_workspace`.

### Find out about ArcPy functionality

<!-- Marc, can we reference the arcpy function list/help page here. What happens if the search_term = "" -> does this return all available functions? -->
`rpygeo_search()` is a helper function to find out about the commandline name of all ArcGIS geoalgorithms at our disposal.
`rpygeo_search` returns all available algorithms that contain the term specified in `search_term` in their name. 
The search term can be plain text or a regular expression.
For example, to find all functions of the ArcPy main module that contain `3d` in their name, we can type: 


```{r, eval=FALSE}
rpygeo_search(search_term = "3d", module = arcpy)
```

If we want to search another module we have to set `module` parameter accordingly.
To search for functions that contain the word `Classify` in their names and that are available via the spatial analyst extension, we write:

```{r, eval=FALSE}
rpygeo_search(search_term = "Classify", module = arcpy$sa)
```

`rpygeo_help()` helps to get familiar with the function parameters of a specific ArcGIS geoalgorithm.

```{r, eval=FALSE}
rpygeo_help(arcpy$Slope_3d)
```

The help file is displayed in the viewer pane of RStudio.
If you use RPyGeo in another IDE, the help file is displayed in the default browser.

### Geoprocessing with ArcPy

ArcPy functions can be accessed via the `$` operator.
You can take advantage of the tab completion feature of RStudio.
After typing the `$` operator all functions of the ArcPy module are listed (which represents an interactive alternative to `rpygeo_search()`).
For example, to compute the slope from the digital elevation model (DEM) we have exported at the beginning of this tutorial, type:

```{r, eval=FALSE}
arcpy$Slope_3d(in_raster = "elev.tif", out_raster = "slope.tif")
```

Executing the function creates a file named `slope.tif` in the workspace directory, which in our case is the temporary folder (see above in `rpygeo_build_env()`).
To import the output of the ArcGIS processing into R, run:

<!-- Marc, is that correct? -->
```{r, eval=FALSE}
slope <- rpygeo_load("slope.tif")
```

This imports the ArcGIS slope processing output into R as a raster object named `slope`.
<!-- Marc: and is this also possible? arcpy$sa$Slope %>% rpygeo_load() -->

The pipe operator `%>%` can be used to chain ArcPy function together. 

```{r, eval = FALSE}
arcpy$Dissolve_management(in_features = "nz.shp", 
                          out_feature_class = "nz_island.shp", 
                          dissolve_field = "Island") %>% a
  arcpy$PolygonToLine_management("nz_border.shp")
```

In this example the `nz.shp` shapefile is dissolved based on the `Island` field.
Subsequently, the polygons are converted to polylines.

<!-- Figure is missing a caption and a reference in the text. -->

![NZ Workflow.](nz.png){width=100%}

### Modules and extensions

To use the functions of a specific extension, one has to enable the extension first (see `rpygeo_build_env()`. 
To access an extension we can make use of the `$` operator.
Then, a second `$` provides access to the functions of the extension.
For example, to compute the slope from a DEM with the help of the Spatial Analyst extension, we can run:

```{r, eval=FALSE}
arcpy$sa$Slope(in_raster = "elev.tif")
```

Note that there is no output parameter, hence the result of the processing will be saved as an Arc/Info Binary Grid file to the scratch workspace location (see again `rpygeo_build_env()`).
To save the output to another location, we can make use of `rpygeo_save()`.

```{r, eval=FALSE}
arcpy$sa$Slope(in_raster = "elev.tif") %>%
  rpygeo_save("slope.tif")
```

### Map algebra

Map algebra expressions can be used in RPyGeo with special operators. 
The four basic calculus functions are implemented as `%rpygeo_+%`, `%rpygeo_-%`, `%rpygeo_*%`, `%rpygeo_/%`. 

<!-- Marc, what kind of object is ras? I suspect it is not an r raster object, we should make this clear here, i.e. explain what arcpy$sa$Raster is doing -->
```{r, eval=FALSE}
ras <- arcpy$sa$Raster("elev.tif") 

ras %rpygeo_+% 2 %>%
  rpygeo_save("elev_2.tif")
```

In this example we created a raster object from the elevation raster. 
Then we added 2 to each pixel value. For map algebra the `rpygeo_save` function is very handy, because the output of map algebra is always a temporary file. 

## Conclusions

Please note that we could not tested each ArcPy function.
Therefore, if you encounter any bugs please report them in our [github repository](https://github.com/fapola/RPyGeo/) under issues or help us fix them them via a pull request.

# References
